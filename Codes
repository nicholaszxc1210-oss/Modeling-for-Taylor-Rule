# paper_linked_model.py
# ----------------------------------------------------------------------------------
# Pressure-Adjusted Taylor Rule — End-to-End Script (100+ lines)
# Implements:
#   §3.1 Baseline Taylor rule
#   §3.2 Political pressure wedge (i_t = i_TR - κ P_t)
#   §3.3 Welfare proxy with a political term
#   §4 Case-study style pressure profiles (US / India / Turkey)
#   §5 Toy NK-style dynamics + simulation + calibration of κ to target shares
#
# What this script does when you run it:
#   1) Simulates paths for inflation (π), output gap (y), and policy rates (baseline vs. pressure-adjusted)
#   2) Calibrates κ so that the mean deviation share ≈ target (US≈0.55, India≈0.40, Turkey≈0.95)
#   3) Re-runs simulations with calibrated κ
#   4) Exports a CSV with all series and PNG figures (one chart per file, default matplotlib style)
#   5) Prints a small JSON with calibrated κ and discounted welfare
#
# Usage:
#   python paper_linked_model.py
#
# Notes:
#   • All data are synthetic and illustrative (reproducible with fixed RNG seeds).
#   • Plots use matplotlib defaults, one figure per image, no custom colors.
# ----------------------------------------------------------------------------------

import os
import json
from dataclasses import dataclass
from typing import Optional

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt


# =========================
# §3.1 — Baseline Taylor rule
# =========================
@dataclass
class TaylorParams:
    r_star: float = 0.5     # neutral real rate (pp)
    pi_star: float = 2.0    # inflation target (pp)
    phi_pi: float = 1.5     # inflation response
    phi_y: float = 0.5      # output gap response
    kappa:  float = 0.4     # pressure pass-through (pp per unit P in [0,1])


def taylor_rule(pi_t: float, y_t: float, par: TaylorParams) -> float:
    """
    i_t^TR = r* + π_t + φ_π (π_t − π*) + φ_y y_t
    """
    return par.r_star + pi_t + par.phi_pi * (pi_t - par.pi_star) + par.phi_y * y_t


# =========================================
# §3.2 — Political pressure wedge adjustment
# =========================================
def pressure_adjusted_rate(pi_t: float, y_t: float, P_t: float, par: TaylorParams) -> float:
    """
    i_t = i_t^TR − κ P_t,  with  P_t ∈ [0,1].
    """
    return taylor_rule(pi_t, y_t, par) - par.kappa * float(np.clip(P_t, 0.0, 1.0))


# ============================================
# §3.3 — Welfare proxy (reduced-form, one period)
# ============================================
@dataclass
class WelfareParams:
    beta: float = 0.97  # discount factor
    lam:  float = 0.5   # weight on output gap in loss
    theta: float = 0.8  # political term weight for P_t * y_t  (encodes “pressure for activity”)


def period_loss(pi: float, y: float, P: float, wpar: WelfareParams, pi_star: float = 2.0) -> float:
    """
    L_t = (π_t − π*)^2 + λ y_t^2 − θ P_t y_t
    (Lower is better; this is a loss, not utility.)
    """
    return (pi - pi_star) ** 2 + wpar.lam * (y ** 2) - wpar.theta * P * y


# ============================================
# §5 — Toy New-Keynesian-style transition
# ============================================
@dataclass
class NKParams:
    a: float = 0.5     # y persistence
    b: float = 0.8     # sensitivity to real rate (i − π)
    g: float = 0.2     # Phillips slope (π responds to y)
    sig_y: float = 0.25
    sig_pi: float = 0.15
    seed: int = 11


def simulate_paths(
    T: int,
    tpar: TaylorParams,
    wpar: WelfareParams,
    npar: NKParams,
    pressure_profile: np.ndarray,
    label: str,
) -> pd.DataFrame:
    """
    Simulate π, y, i_TR, i_adj, pressure, deviation, period loss, and cumulative discounted loss.
    """
    rng = np.random.default_rng(npar.seed)

    pi = np.zeros(T + 1)
    y = np.zeros(T + 1)
    i_tr = np.zeros(T)
    i_adj = np.zeros(T)
    loss = np.zeros(T)

    # Initial conditions
    pi[0] = tpar.pi_star + rng.normal(0, 0.30)
    y[0] = rng.normal(0, 0.40)

    for t in range(T):
        # Policy
        i_tr[t] = taylor_rule(pi[t], y[t], tpar)
        i_adj[t] = i_tr[t] - tpar.kappa * pressure_profile[t]

        # Welfare (proxy)
        loss[t] = period_loss(pi[t], y[t], pressure_profile[t], wpar, pi_star=tpar.pi_star)

        # NK-ish transitions
        real_rate = i_adj[t] - pi[t]
        y[t + 1] = npar.a * y[t] - npar.b * real_rate + rng.normal(0, npar.sig_y)
        pi[t + 1] = pi[t] + npar.g * y[t] + rng.normal(0, npar.sig_pi)

    # Discounted welfare metric
    disc = np.power(wpar.beta, np.arange(T))
    W = float(np.sum(disc * loss))

    # Assemble output frame
    df_state = pd.DataFrame({"t": np.arange(T + 1), "pi": pi, "y": y})
    df_flow = pd.DataFrame(
        {
            "t": np.arange(T),
            "i_tr": i_tr,
            "i_adj": i_adj,
            "pressure": pressure_profile[:T],
            "loss": loss,
        }
    )
    out = df_state.merge(df_flow, how="left", on="t")
    out["scenario"] = label
    out["deviation"] = out["i_tr"] - out["i_adj"]
    out["cum_discounted_loss"] = np.concatenate([[0], np.cumsum(disc * loss)])
    out.attrs["W_discounted"] = W
    return out


# ===============================================
# §4 — Scenario pressure profiles (US / India / TR)
# ===============================================
def pressure_profile_us(T: int) -> np.ndarray:
    # Intermittent medium spikes (e.g., comms cycles)
    P = np.zeros(T)
    idx = [10, 12, 14, 18, 22, 28, 31, 33, 37, 40, 44, 47, 50, 52, 55]
    for i in idx:
        if i < T:
            P[i] = 0.8
            if i + 1 < T:
                P[i + 1] = 0.5
    return P


def pressure_profile_india(T: int) -> np.ndarray:
    # Moderate pressure around leadership change & pre-election
    P = np.zeros(T)
    P[20:26] = 0.4
    P[26:32] = 0.7
    P[32:38] = 0.6
    return P


def pressure_profile_turkey(T: int) -> np.ndarray:
    # Sustained, elevated pressure
    P = np.ones(T) * 0.9
    P[10:20] = 1.0
    P[30:40] = 1.0
    return P


# =========================================================
# Calibration helper — scale κ to hit an average share target
# =========================================================
def calibrate_kappa_for_share(df: pd.DataFrame, target_share: float, base_kappa: float) -> float:
    """
    Crude scaling so that:
        mean(deviation) / mean(|i_TR|)  ≈  target_share.
    """
    scale = float(np.maximum(df["i_tr"].abs().mean(), 1e-6))
    cur = float((df["i_tr"] - df["i_adj"]).mean() / scale)
    if cur <= 0:
        return base_kappa
    return base_kappa * (target_share / cur)


# ===========================
# Plot helpers (1 plot/figure)
# ===========================
def plot_policy_paths(df: pd.DataFrame, scenario: str, fname: str) -> None:
    sub = df[df["scenario"] == scenario].reset_index(drop=True)
    plt.figure()
    plt.plot(sub["i_tr"], label="Taylor rule (baseline)")
    plt.plot(sub["i_adj"], label="Pressure-adjusted")
    plt.title(f"Policy path — {scenario}")
    plt.xlabel("Time")
    plt.ylabel("Rate (pp)")
    plt.legend()
    plt.tight_layout()
    plt.savefig(fname, dpi=200)
    plt.close()


def plot_scatter_pressure_deviation(df: pd.DataFrame, scenario: str, fname: str) -> None:
    sub = df[(df["scenario"] == scenario) & (~df["deviation"].isna())]
    plt.figure()
    plt.scatter(sub["pressure"], sub["deviation"])
    plt.title(f"Pressure vs. deviation — {scenario}")
    plt.xlabel("Pressure index (0–1)")
    plt.ylabel("Deviation (i_TR − i_adj, pp)")
    plt.tight_layout()
    plt.savefig(fname, dpi=200)
    plt.close()


def plot_state_paths(df: pd.DataFrame, scenario: str, fname_pi: str, fname_y: str) -> None:
    sub = df[df["scenario"] == scenario].reset_index(drop=True)

    plt.figure()
    plt.plot(sub["pi"], label="Inflation")
    plt.title(f"Inflation path — {scenario}")
    plt.xlabel("Time")
    plt.ylabel("π (pp)")
    plt.tight_layout()
    plt.savefig(fname_pi, dpi=200)
    plt.close()

    plt.figure()
    plt.plot(sub["y"], label="Output gap")
    plt.title(f"Output gap path — {scenario}")
    plt.xlabel("Time")
    plt.ylabel("y (pp)")
    plt.tight_layout()
    plt.savefig(fname_y, dpi=200)
    plt.close()


def plot_share_over_time(df: pd.DataFrame, scenario: str, fname: str) -> None:
    sub = df[df["scenario"] == scenario].reset_index(drop=True)
    share = sub["deviation"] / (sub["i_tr"].abs() + 1e-6)
    plt.figure()
    plt.plot(share.values, label="Deviation share (approx)")
    plt.title(f"Approx. influence share — {scenario}")
    plt.xlabel("Time")
    plt.ylabel("Share")
    plt.tight_layout()
    plt.savefig(fname, dpi=200)
    plt.close()


# =====================
# Main orchestration
# =====================
def run_all(T: int = 100, outdir: str = ".") -> tuple[pd.DataFrame, dict]:
    os.makedirs(outdir, exist_ok=True)

    # Parameters (you can tune these)
    tpar = TaylorParams(r_star=0.5, pi_star=2.0, phi_pi=1.5, phi_y=0.5, kappa=0.4)
    wpar = WelfareParams(beta=0.97, lam=0.5, theta=0.8)
    npar = NKParams(a=0.5, b=0.8, g=0.2, sig_y=0.25, sig_pi=0.15, seed=11)

    # Baseline runs with provisional κ (to compute scale for calibration)
    P_us = pressure_profile_us(T)
    P_in = pressure_profile_india(T)
    P_tr = pressure_profile_turkey(T)

    df_us0 = simulate_paths(T, tpar, wpar, npar, P_us, label="US")
    df_in0 = simulate_paths(T, tpar, wpar, npar, P_in, label="India")
    df_tr0 = simulate_paths(T, tpar, wpar, npar, P_tr, label="Turkey")

    # Calibrate κ to qualitative targets (share ≈ mean deviation / mean |i_TR|)
    k_us = calibrate_kappa_for_share(df_us0, target_share=0.55, base_kappa=tpar.kappa)
    k_in = calibrate_kappa_for_share(df_in0, target_share=0.40, base_kappa=tpar.kappa)
    k_tr = calibrate_kappa_for_share(df_tr0, target_share=0.95, base_kappa=tpar.kappa)

    # Re-simulate with calibrated κ
    tpar_us = TaylorParams(**{**tpar.__dict__, "kappa": k_us})
    tpar_in = TaylorParams(**{**tpar.__dict__, "kappa": k_in})
    tpar_tr = TaylorParams(**{**tpar.__dict__, "kappa": k_tr})

    df_us = simulate_paths(T, tpar_us, wpar, npar, P_us, label="US")
    df_in = simulate_paths(T, tpar_in, wpar, npar, P_in, label="India")
    df_tr = simulate_paths(T, tpar_tr, wpar, npar, P_tr, label="Turkey")

    df_all = pd.concat([df_us, df_in, df_tr], axis=0).reset_index(drop=True)

    # Export CSV
    csv_path = os.path.join(outdir, "simulated_series_all.csv")
    df_all.to_csv(csv_path, index=False)

    # Figures (one plot per file)
    plot_policy_paths(df_all, "US", os.path.join(outdir, "fig_policy_US.png"))
    plot_policy_paths(df_all, "India", os.path.join(outdir, "fig_policy_India.png"))
    plot_policy_paths(df_all, "Turkey", os.path.join(outdir, "fig_policy_Turkey.png"))

    plot_scatter_pressure_deviation(df_all, "US", os.path.join(outdir, "fig_scatter_US.png"))
    plot_scatter_pressure_deviation(df_all, "India", os.path.join(outdir, "fig_scatter_India.png"))
    plot_scatter_pressure_deviation(df_all, "Turkey", os.path.join(outdir, "fig_scatter_Turkey.png"))

    plot_state_paths(
        df_all,
        "US",
        os.path.join(outdir, "fig_infl_US.png"),
        os.path.join(outdir, "fig_out_US.png"),
    )
    plot_state_paths(
        df_all,
        "India",
        os.path.join(outdir, "fig_infl_India.png"),
        os.path.join(outdir, "fig_out_India.png"),
    )
    plot_state_paths(
        df_all,
        "Turkey",
        os.path.join(outdir, "fig_infl_Turkey.png"),
        os.path.join(outdir, "fig_out_Turkey.png"),
    )

    plot_share_over_time(df_all, "US", os.path.join(outdir, "fig_share_US.png"))
    plot_share_over_time(df_all, "India", os.path.join(outdir, "fig_share_India.png"))
    plot_share_over_time(df_all, "Turkey", os.path.join(outdir, "fig_share_Turkey.png"))

    # Meta summary
    meta = {
        "kappas": {"US": float(k_us), "India": float(k_in), "Turkey": float(k_tr)},
        "welfare": {
            "US": df_us.attrs.get("W_discounted"),
            "India": df_in.attrs.get("W_discounted"),
            "Turkey": df_tr.attrs.get("W_discounted"),
        },
    }
    with open(os.path.join(outdir, "calibration_meta.json"), "w") as f:
        json.dump(meta, f, indent=2)

    return df_all, meta


if __name__ == "__main__":
    # Run in current directory; change outdir if you want a subfolder
    df, meta = run_all(T=100, outdir=".")
    print(json.dumps(meta, indent=2))
